// Code generated by mockery v2.33.2. DO NOT EDIT.

package database

import (
	context "context"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockDeploymentStore is an autogenerated mock type for the DeploymentStore type
type MockDeploymentStore struct {
	mock.Mock
}

// Deployment provides a mock function with given fields: ctx, id
func (_m *MockDeploymentStore) Deployment(ctx context.Context, id string) (*Deployment, error) {
	ret := _m.Called(ctx, id)

	var r0 *Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Deployment, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Deployment); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentResources provides a mock function with given fields: ctx, deploymentID
func (_m *MockDeploymentStore) DeploymentResources(ctx context.Context, deploymentID string) ([]DeploymentResource, error) {
	ret := _m.Called(ctx, deploymentID)

	var r0 []DeploymentResource
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]DeploymentResource, error)); ok {
		return rf(ctx, deploymentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []DeploymentResource); ok {
		r0 = rf(ctx, deploymentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]DeploymentResource)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, deploymentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentStatus provides a mock function with given fields: ctx, deploymentID
func (_m *MockDeploymentStore) DeploymentStatus(ctx context.Context, deploymentID string) ([]DeploymentStatus, error) {
	ret := _m.Called(ctx, deploymentID)

	var r0 []DeploymentStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]DeploymentStatus, error)); ok {
		return rf(ctx, deploymentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []DeploymentStatus); ok {
		r0 = rf(ctx, deploymentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]DeploymentStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, deploymentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Deployments provides a mock function with given fields: ctx, teams, clusters, ignoreTeams, limit
func (_m *MockDeploymentStore) Deployments(ctx context.Context, teams []string, clusters []string, ignoreTeams []string, limit int) ([]*Deployment, error) {
	ret := _m.Called(ctx, teams, clusters, ignoreTeams, limit)

	var r0 []*Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, []string, []string, int) ([]*Deployment, error)); ok {
		return rf(ctx, teams, clusters, ignoreTeams, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, []string, []string, int) []*Deployment); ok {
		r0 = rf(ctx, teams, clusters, ignoreTeams, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, []string, []string, int) error); ok {
		r1 = rf(ctx, teams, clusters, ignoreTeams, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HistoricDeployments provides a mock function with given fields: ctx, cluster, timestamp
func (_m *MockDeploymentStore) HistoricDeployments(ctx context.Context, cluster string, timestamp time.Time) ([]*Deployment, error) {
	ret := _m.Called(ctx, cluster, timestamp)

	var r0 []*Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) ([]*Deployment, error)); ok {
		return rf(ctx, cluster, timestamp)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) []*Deployment); ok {
		r0 = rf(ctx, cluster, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, time.Time) error); ok {
		r1 = rf(ctx, cluster, timestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WriteDeployment provides a mock function with given fields: ctx, deployment
func (_m *MockDeploymentStore) WriteDeployment(ctx context.Context, deployment Deployment) error {
	ret := _m.Called(ctx, deployment)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Deployment) error); ok {
		r0 = rf(ctx, deployment)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteDeploymentResource provides a mock function with given fields: ctx, resource
func (_m *MockDeploymentStore) WriteDeploymentResource(ctx context.Context, resource DeploymentResource) error {
	ret := _m.Called(ctx, resource)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DeploymentResource) error); ok {
		r0 = rf(ctx, resource)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WriteDeploymentStatus provides a mock function with given fields: ctx, status
func (_m *MockDeploymentStore) WriteDeploymentStatus(ctx context.Context, status DeploymentStatus) error {
	ret := _m.Called(ctx, status)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DeploymentStatus) error); ok {
		r0 = rf(ctx, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewMockDeploymentStore creates a new instance of MockDeploymentStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDeploymentStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDeploymentStore {
	mock := &MockDeploymentStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
